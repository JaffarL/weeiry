# 事件委托

废话少说，先看图：

![eventflow](eventflow.svg)

如图所示，事件模型分为三个阶段。

1. 捕获阶段：事件触发之后由最上层window捕获（只能触发捕获函数），向下逐层传递至document,html,body...直到目标元素
2. 目标阶段：传递至目标元素触发相应绑定的事件响应函数，若事件类型指定此事件不进行冒泡，则事件传递过程就此结束
3. 冒泡阶段：事件再由目标元素开始逐层向上传递（触发冒泡函数）直到window对象

由于事件冒泡时候会将事件向上传播到父节点，所以可以将子节点的监听函数定义在父节点上，一个父节点监听并处理多个子元素的事件，这就是事件代理

## 为何要用事件代理

1. 绑定事件越来越多
2. ajax带来的大量局部刷新导致每次加载完重新绑定事件
3. 移除元素的时候，绑定的事件未被及时移除，内存泄漏，影响性能

## 事件代理的优点

1. 减少监听器数量，减少内存消耗，提高效率
2. 动态的绑定事件，减少重复工作量

*未完待续*