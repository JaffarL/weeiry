# 正则表达式

## 如何创建一个正则表达式

1. 使用正则表达式字面量

```js
const regex = /ab+c/;

const regex = /^[a-zA-Z]+[0-9]*\W?_$/gi;

```

当正则表达式不需变化时，推荐使用字面量方式，因为性能比较好
2. 使用RegExp的构造函数对象

```js
let regex = new RegExp("ab+c");

let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$/, "gi");

let regex = new RegExp("^[a-zA-Z]+[0-9]*\\W?_$", "gi");

```

## 编写一个正则表达式的模式

1. 简单模式

形如 '/abc/' 的正则表达式会匹配'do you like your abc's'这种语句，感觉不用多说。

2. 特殊字符

以下是所有特殊字符

|字符|作用|
|------|:----:|
| \ |转译，下一个是特殊字符|
|^|输入的开始|
|$|输入的结束|
|*|前一个表达式0次或多次，等价于{0,}|
|+|前一个表达式1次或多次，等价于{1,}|
|?|前一个表达式0次或1次，等价于{0,1};若紧跟在任何量词(*,+,?或者{})后面，则会使量词变为懒惰的(匹配尽量少的字符)，还可用于零宽断言|
|.|匹配除换行符外任意单个字符|
|(exp)|匹配exp并|
|[^xyz]|反向字符集，即匹配任何没有包含在中括号内的字符|
|\d|匹配一个数字，等价于[0-9]|
|\D|匹配一个非数字字符，等价于[^0-9]|
|\n|匹配一个换行符|
|\r|匹配一个回车符|
|\s|匹配一个空白字符，包括空格，制表，换页，换行符|
|\S|匹配一个非空白字符|
|\w|匹配一个单字字符（字母、数字或者下划线）等价于[A-Za-z0-9_]|
|\W|匹配一个非单字字符，等价于[^A-Za-z0-9_]|
***未完待续***

3. 正则表达式标志

> g :全局搜索，即多次匹配
> i：不区分大小写

## 小括号，中括号，大括号的区别

1. ()小括号匹配字符串后可以被记住，并在函数调用中作为参数传入 $1,$2，详情见参考资料
2. []中括号匹配的是中括号内部的表达式所代表的范围，例如[0-9]匹配这个位置上的所有数字,[a-z]*匹配这个位置出现所有小写字母。
3. {}大括号代表前一个表达式出现的次数。

## 贪婪&&惰性

贪婪即正则表达式匹配最远，惰性即正则表达式匹配最近

例如aaaa,/a*/默认贪婪模式匹配整个字符串，/a*?/则进入惰性模式遇到第一个第一个a正则匹配就结束了

详情参加参考资料

## 零宽断言

这玩意儿不好用形式化语言描述，因为我看了N多资料的形式化语言定义却根本看不懂是什么意思。

简单地说：零宽断言就是一个表达式，正则表达式匹配符合零宽断言条件的语句但是最后不对其进行捕捉
。比如：我需要捕获一个abc字符串，***但此字符串之前必须有两个数字，或者必须不能有数字***，这种条件判断就是用零宽断言来做。

零宽断言有4种

### (?=exp)

零宽度正预测先行断言 匹配exp前面的内容

例如要匹配cooking,singing,doing中除了ing之外的内容，可以用[a-z]*(?=ing)来匹配

执行步骤是从输入字符串最右侧开始找到第一个符合条件的ing，然后在匹配ing之前的表达式，符合正则的贪婪性，例如.*(?=ing) 可以匹配 “cooking singing” 中的 “cooking sing” 而不是 cook

### (?<=exp)

零宽度正回顾后发断言 匹配exp后面的内容

例如(?<=abc).*可以匹配abcdefg的defg

与先行断言相反，从左侧开始匹配

### (?!exp)

负向零宽先行断言

与正预测相反，当此位置不出现exp的内容时匹配成功

### (?<!exp)

负向零宽后发断言

很好理解，参考以上。

[参考资料](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)